<!DOCTYPE html>
<html lang="en">
<!-- Nav Bar from https://www.w3schools.com/howto/howto_js_dropdown.asp-->

	<head>
		<meta charset = "utf-8">
		<title>Ishan's Portfolio</title>
		<link rel="stylesheet" type="text/css" href="../design.css">  
		<link rel="stylesheet" type="text/css" href="../NavBar.css">
	</head>


	<body>
		<header>
			<nav>
				<div class="navbar">
					<a href="../index.html">
						<img src="../Images/assets/Logo.png" class="logo"> 
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Home
					</a>
					<div class="dropdown">
						<button class="dropbtn">Projects <i class="fa fa-caret-down"></i></button>
						<div class="dropdown-content">
						  <a href="../projects/ics203.html">Towers of Hanoi</a>
						  <a href="../projects/ics3u3.html">Snakes and Ladders</a>
							<a href="../projects/quick-sort.html">Quick Sort</a>
                            <a href="../projects/ics4u0.html">Bus Condutor</a>
				  		</div>
				  	</div> 
					<div class="dropdown">
						<button class="dropbtn">Tutorials 
						  <i class="fa fa-caret-down"></i>
						</button>
						<div class="dropdown-content">
                            <a href="OOP.html">Object Oriented Programming</a>
                            <a href="Arrays.html">Arrays and ArrayLists</a>
                            <a href="Search.html">Search and Sort</a>
                          </div>
					  </div> 
				</div>
			</nav>
        </header>
		<div class = "title">
			<h1>Searching and Sorting Algorithims</h1>
		</div>
        <div class="text">
			 <div class="fade">
                 <h1>What is a Sorting Algorithm?</h1>
                 <p>
                     Sorting is the task of taking a set of some object, and putting it in a certain order or sequence. Humans use sorting everyday, whether it's something as simple seperating colors from whites while doing the laundry, to the massive SQL data tables used to store the data for all the applications and websites we use. Sorting is an essential part of not only Computer Science, but also our society. For this tutorial, we will be using an example of an integer <a href="Arrays.html">array</a> being sorted from the lowest, to the highest. But before we fully dive into the sorting algorithims, there are some basic vocabulary you should know first.
                 </p>
                 
                 <h1>Time, Space Complexity & Big O Notation:</h1>
                 <p>
                     Computer scientists judged an algorithim on several factors, but mainly on it's <b>Time</b> and <b>Space Complexity</b>. Time complexity is how much time is needed for the Algorithim to complete. Space complexity is how much extra memory (variables) is needed at any point for an algorithim to work. We denote both Time and Space complexity through a language called <b>Big O notation</b>. Here is a graph of all the Time Complexities:
                     <img src="../Images/Big0.jpeg" style="display:block; margin-left:auto; margin-right:auto; width: 60%">
                     The n in Big 0 notation is how many elements, and the O represents how much time. The best sorting algorithms are normally O(n) and better as they require only one pass through or less of the array to complete the sort. The worst algorithms typically require much time, O(n^2) means you have to make length square pass throughs, or comparisions to sort the array.
                 </p>
                 <h1>Bubble Sort:</h1>
                 <p>
                     Bubble Sort (also called Shell Sort) is one of, if not the simplest, sorting algorithim to implement. The main premise of Bubble Sort is this:
                 </p>
                 <ol>
                     <li> If two adjacent values are out of order:</li>
                     <ul>
                         <li>Swap them</li>
                     </ul>
                     <li> Repeat for every element in the array, or until no more swaps were made.</li>
                 </ol>
                 <p><br>
                     Here is an implementation of Bubble Sort in Java:
                 </p>
                 <div class="code">
                     <pre>public void BubbleSort(int[] in) {
    for (int i = 0; i &lt in.length - 1;i i++) {
        for (int x = 0; x &lt in.length-i-1; x++) {
            if (in[x] &gt inn[x+1]) {
                // Swapping if the elements are out of order
                int temp = in[x+1];
                in[x+1] = in[x];
                in[x] = temp;
            } 
        }
    }
}</pre>
                 </div>
                 <p><br>
                     Bubble Sort is so easy to implement, but that also makes it one of the most inefficient sorting algorithms. Bubble Sort's average and worst case time complexity is O(n^2), because you have to loop from 0 to the end of the array for every element in the array. Because of this, Bubble sort is rarely ever used, except to teach the basic concepts of a Sorting Algorithim (or if the programmer gets really, really, lazy).
                 </p>
                 <p>For a more comprehensive list of all the sorting algorithims, check out this <a href="https://www.geeksforgeeks.org/sorting-algorithms/" target="_blank">GeeksForGeeks page</a>.</p>
                 
                 <h1> What is a Searching Algorithim?</h1>
                 <p>
                     Searching is another very common task, that humans and computers use everyday. Whether you are looking for a matching pair of socks in the morning, to finding this very website and Googling anything on the internet, you probably used some version of a Searching Algorithm. Searching Algorithms use the same Big O notation to describe efficiency.
                 </p>
                 <h1>Sequential Search</h1>
                 <p>
                     Sequential, or Linear Search is the simplest searching algorithm, but also the most ineffecient. On a small scale it works, but as you get longer and longer lists to search through it quickly becomes ineffecient. For sequential search, you simply loop through every item in your data set, and if it is equal to what you are looking for, return that index. If not, move on to the next element and check. Time Complexity for sequential search is O(n) as worse case it has to loop through every element. Here is an implementation in Java:
                 </p>
                 <div class="code">
                 <pre>public int linearSearch (int[] in, int target) {
    for (int i = 0; i &lt in.length; i++) {
        if (in[i] == target) {
            return i;    // Returns the index once found
        }
    }
    return-1; // Returns -1 if target was not found
}</pre>
                 </div>
                 <h1>Binary Search</h1>
                 <p>
                     Binary search is another very common searching algorithm that involves splitting the array in two sub parts, hence the name "binary". The prerequisite for binary search is that the array must be sorted before you begin your search. The time complexity for Binary Search is O(log n). Once you have a sorted array, you do the following:
                 </p>
                 <ol>
                     <li>Take the middle of the current array and compare it to the target</li>
                     <li>If the target is equal to the middle, return the current  middle</li>
                     <li>If the target is greater then the middle, restart with the subarray of all the values greater then the current middle</li>
                     <li>If the target is less then the middle, restart with the subarray of all the values less then the current middle</li>
                     <li>If you get to a subarry of length 1, and the middle isn't equal to the target, then the target isn't in the array</li>
                 </ol>
                 <p><br>
                     For binary search, there are multiple ways to implement it either iteratively through a loop, or recursively. This demonstration in Java uses a loop:
                 </p>
                 <div class="code">
                     <pre>public int binarySearch(int[] in, int target) {
    int left = 0;
    int right = in.length - 1;
    
    while (right &gt= left) {
        int middle = (right + left)/2;
        if (in[middle] == target)
            return middle
        if (arr[mid] &gt target)
            left = middle + 1;
        else 
            right = middle - 1;
    }
    // once right is less then left, that means that the target wasnt found
    return -1;
}</pre>
                    
                 </div>
                 <p>For a more comprehensive list of all the searching algorithims, check out this <a href="https://www.geeksforgeeks.org/searching-algorithms/" target="_blank">GeeksForGeeks page</a>.</p>
             </div>
		</div>
	</body>
</html>